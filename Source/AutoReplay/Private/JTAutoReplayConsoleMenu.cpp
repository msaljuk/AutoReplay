// Copyright 2024 JukiTech. All Rights Reserved.

#include "JTAutoReplayConsoleMenu.h"

#include "InputPlayer/JTInputPlayer.h"
#include "InputRecorder/JTInputRecorder.h"
#include "InputSerializer/JTInputSerializer.h"

#include "CoreMinimal.h"
#include "Engine/World.h"

namespace JT
{
	namespace AutoReplay
	{
		namespace InputPlayer
		{
			FAutoConsoleCommandWithWorldAndArgs CCommandRequestPlay(
				TEXT("jt.autoreplay.inputplayer.requestplay"),
				TEXT("Request the input player to play a given session. Args:\n")
				TEXT("[session filename to play]\n")
				TEXT("[OPTIONAL: [1/0] - whether to restore player spatial data at start (default 1)]\n")
				TEXT("[OPTIONAL: [0-inf] - time delay (in seconds) before starting (default 0)]\n")
				TEXT("[OPTIONAL: [1-inf] - number of times to play (default 1. Negative values mean loop infinitely)"),
				FConsoleCommandWithWorldAndArgsDelegate::CreateLambda([](const TArray<FString>& InParams, UWorld* InWorld)
					{
						if (InParams.IsEmpty())
						{
							return;
						}

						if (!IsValid(InWorld))
						{
							return;
						}

						FJTInputPlayerRequestParams InputPlayerRequestParams;
						for (int32 Index = 0; Index < InParams.Num(); ++Index)
						{
							const FString& CurrentString = InParams[Index];
							if (Index == 0)
							{
								InputPlayerRequestParams.RecordingFilePath.FilePath = CurrentString;
							}
							else if (Index == 1)
							{
								InputPlayerRequestParams.bRestorePlayerSpatialDataOnStart = static_cast<bool>(FCString::Atoi(*CurrentString));
							}
							else if (Index == 2)
							{
								InputPlayerRequestParams.TimeDelayBeforePlaying = FCString::Atof(*CurrentString);
							}
							else if (Index == 3)
							{
								InputPlayerRequestParams.NumTimesToPlay = FCString::Atoi(*CurrentString);
							}
						}

						UJTInputPlayer* InputPlayer = InWorld->GetSubsystem<UJTInputPlayer>();
						if (!IsValid(InputPlayer))
						{
							return;
						}

						InputPlayer->RequestPlay(InputPlayerRequestParams);
					}));

			FAutoConsoleCommandWithWorldAndArgs CCommandStopPlaying(
				TEXT("jt.autoreplay.inputplayer.stopplaying"),
				TEXT("Request the input player to stop the current play session"),
				FConsoleCommandWithWorldAndArgsDelegate::CreateLambda([](const TArray<FString>& InParams, UWorld* InWorld)
					{
						if (!IsValid(InWorld))
						{
							return;
						}

						UJTInputPlayer* InputPlayer = InWorld->GetSubsystem<UJTInputPlayer>();
						if (!IsValid(InputPlayer))
						{
							return;
						}

						InputPlayer->StopPlaying();
					}));

			TAutoConsoleVariable<bool> CVarShowPlayStatus(
				TEXT("jt.autoreplay.inputplayer.showplaystatus"),
				true,
				TEXT("Shows the current play status for the input player"));
		} // Input Player

		namespace InputRecorder
		{
			FAutoConsoleCommandWithWorldAndArgs CCommandRequestRecording(
				TEXT("jt.autoreplay.inputrecorder.requestrecording"),
				TEXT("Request the input recorder to start a new recording session. Args: \n")
				TEXT("[OPTIONAL: name of recording file (will be autogenerated by default)] \n")
				TEXT("[OPTIONAL: [0-inf] - time delay (in seconds) before starting (default 0)] \n")
				TEXT("[OPTIONAL: [1/0] - whether to record input when game is paused (default 0)]"),
				FConsoleCommandWithWorldAndArgsDelegate::CreateLambda([](const TArray<FString>& InParams, UWorld* InWorld)
					{
						if (!IsValid(InWorld))
						{
							return;
						}

						FJTInputRecorderRequestParams InputRecorderRequestParams;
						for (int32 Index = 0; Index < InParams.Num(); ++Index)
						{
							const FString& CurrentString = InParams[Index];
							if (Index == 0)
							{
								InputRecorderRequestParams.RecordingFilePath.FilePath = CurrentString;
							}
							else if (Index == 1)
							{
								InputRecorderRequestParams.TimeDelayBeforeRecording = FCString::Atof(*CurrentString);
							}
							else if (Index == 2)
							{
								InputRecorderRequestParams.bRecordInputWhenGamePaused = static_cast<bool>(FCString::Atoi(*CurrentString));
							}
						}

						UGameInstance* GameInstance = InWorld->GetGameInstance();
						if (!IsValid(GameInstance))
						{
							return;
						}

						UJTInputRecorder* InputRecorder = GameInstance->GetSubsystem<UJTInputRecorder>();
						if (!IsValid(InputRecorder))
						{
							return;
						}

						InputRecorder->RequestRecording(InputRecorderRequestParams);
					}));

			FAutoConsoleCommandWithWorldAndArgs CCommandStopRecording(
				TEXT("jt.autoreplay.inputrecorder.stoprecording"),
				TEXT("Request the input recorder to stop the current recording session"),
				FConsoleCommandWithWorldAndArgsDelegate::CreateLambda([](const TArray<FString>& InParams, UWorld* InWorld)
					{
						if (!IsValid(InWorld))
						{
							return;
						}

						UGameInstance* GameInstance = InWorld->GetGameInstance();
						if (!IsValid(GameInstance))
						{
							return;
						}

						UJTInputRecorder* InputRecorder = GameInstance->GetSubsystem<UJTInputRecorder>();
						if (!IsValid(InputRecorder))
						{
							return;
						}

						InputRecorder->StopRecording();
					}));

			TAutoConsoleVariable<bool> CVarShowRecordingStatus(
				TEXT("jt.autoreplay.inputrecorder.showrecordingstatus"),
				true,
				TEXT("Shows the current recording status for the input recorder"));
		} // Input Recorder
	} // namespace AutoReplay
} // namespace JT
